In this exercise, you get better visibility of all the data generated by OpenTelemetry in your app. You finish adding diagnostics capability to the Store service. With that in place, you add Prometheus and Grafana to the **:::no-loc text="eShopLite":::** services and look at some of the metrics being captured. The next step is to add Zipkin and view the distributed traces. Finally, you add Application Insights to your app and use it to view the data.

## Add Prometheus and Grafana

Prometheus and Grafana provide Docker images that make it easy to add them to your projects. You include them in the *docker-compose.yml* file, in the root of the solution.

1. In Visual Studio Code, on the **EXPLORER** pane, select the *docker-compose.yml* file.
1. Add this YAML to the bottom of the file:

    ```yml
      prometheus:
        image: prom/prometheus
        container_name: prometheus
        command:
          - '--config.file=/etc/prometheus/prometheus.yml'
        ports:
          - 9090:9090
        restart: unless-stopped
        volumes:
          - ./prometheus:/etc/prometheus
      
      grafana:
        image: grafana/grafana
        container_name: grafana
        ports:
          - 3000:3000
        restart: unless-stopped
        environment:
          - GF_SECURITY_ADMIN_USER=admin
          - GF_SECURITY_ADMIN_PASSWORD=grafana
        volumes:
          - ./grafana/datasource:/etc/grafana/provisioning/datasources
    ```

The preceding Docker yaml adds two new services, **Prometheus** and **Grafana**. The Prometheus section configures a container to respond on port **9090**. It maps the *prometheus* folder expecting a *prometheus.yml* file. The Grafana section configures a container to respond on port **3000**. It maps three folders inside a *grafana* folder.

### Configure Prometheus

Prometheus needs to be configured so that it knows where to collect the metrics. You add a *prometheus.yml* file to the *prometheus* folder.

1. In Visual Studio Code, on the **EXPLORER** pane, right-click the *dotnet-observability* folder and then select **New Folder**.
1. In the name field, enter<!--CE:Please check: Should 'prometheus' be capitalized here and in steps 3 and 4?--> **prometheus**.
1. On the **EXPLORER** pane, right-click the *prometheus* folder and then select **New File**.
1. In the name field, enter **prometheus.yml**.
1. In the file editor, enter this YAML:

    ```yml
    global:
      scrape_interval: 1s
    
    scrape_configs:
      - job_name: 'products'
        static_configs:
          - targets: ['backend:8080']
      - job_name: 'store'
        static_configs:
          - targets: ['frontend:8080']
    ```

    The preceding YAML configures Prometheus to scrape metrics from the **back-end** and **front-end** services. As the app is running in Docker the host names are the service names.

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

### Configure Grafana

Grafana needs to be configured so that it knows where to collect the metrics.

1. In Visual Studio Code, on the **EXPLORER** pane, right-click the *dotnet-observability* folder and then select **New Folder**.
1. In the name field, enter **grafana**.
1. Right-click the *grafana* folder and then select **New Folder**.
1. In the name field, enter **datasource**.
1. Right-click the *grafana* folder and then select **New Folder**.
1. In the name field, enter **dashboard**.
1. Expand the *grafana* folder, right-click the *datasource* folder, and then select **New File**.
1. In the name field, enter **datasource.yml**.
1. On the editor tab, enter this YAML:

    ```yml
    apiVersion: 1
    
    datasources:
    - name: Prometheus
      type: prometheus
      url: http://prometheus:9090 
      isDefault: true
      access: proxy
      editable: true
    ```

    The preceding YAML configures Grafana to use Prometheus as the data source.

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

### Update your ASP.NET Core app to expose metrics for Prometheus

Now, the diagnostics project is only configured to expose metrics to the console. You update the project to expose metrics to Prometheus instead.

1. In Visual Studio Code, on the **TERMINAL** pane at the bottom, go to the *Diagnostics* folder.

1. Run this command:

    ```bash
    cd .\eShopLite\Diagnostics\ 
    ```

1. Remove the `OpenTelemetry.Exporter.Console` package:

    ```bash
    dotnet remove package OpenTelemetry.Exporter.Console
    ```

1. Add the `OpenTelemetry.Exporter.Prometheus.AspNetCore` package:

    ```bash
    dotnet add package OpenTelemetry.Exporter.Prometheus.AspNetCore --prerelease
    ```

1. On the **EXPLORER** pane, expand the *Diagnostics* folder and then select **DiagnosticServiceCollectionExtensions.cs**.
1. Replace the console exporter `.AddConsoleExporter();` with this code:

    ```csharp
    .AddPrometheusExporter();
    ```

1. At the bottom of the file, before the last `}`, add this code:

    ```csharp
    public static void MapObservability(this IEndpointRouteBuilder routes)
    {
      routes.MapPrometheusScrapingEndpoint();
    }
    ```

    This code adds a Prometheus scraping endpoint to every service that includes this with their app. This allows Prometheus to scrape metrics from `http://service/metrics`.

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

### Expose metrics in the Store service

The app is currently only configured to expose metrics for the **Products** service. You update the app to expose metrics for the **Store** service too.

1. On the **EXPLORER** pane, under **SOLUTION EXPLORER**, right-click the **Store** project and then select **Add Project Reference**.
1. Select **Diagnostics**.
1. On the **EXPLORER** pane, expand the *Store* folder and then select **Program.cs**.
1. Under the code comment `// Add observability code here`, add a call to the Diagnostics method:

    ```csharp
    builder.Services.AddObservability("Store", builder.Configuration);
    ```

1. Before the `app.Run()` method, add this code:

    ```csharp
    app.MapObservability();
    ```

    This method adds the Prometheus scraping endpoint to the **Store** service.

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

1. On the **EXPLORER** pane, expand the **Product** folder and then select **Program.cs**.

1. Before the `app.Run()` method, add this code:

    ```csharp
    app.MapObservability();
    ```

    This method adds the Prometheus scraping endpoint to the **Products** service.

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

### Test the new observability features

You now test the new observability features you added to the app.

1. On the **TERMINAL** pane at the bottom, go to the *dotnet-observability/eShopLite* folder.

    ```bash
    cd ..
    ```

1. Update the apps containers.

    ```dotnetcli
    dotnet publish /p:PublishProfile=DefaultContainer 
    ```
    

1. Go to the *dotnet-observability* folder, and start the app with Docker:

    ```bash
    cd ..
    docker compose up
    ```

1. On the **PORTS** tab, select **Open in Browser** for **Prometheus (9090)**. If you're running locally in Visual Studio Code, open a browser and, on a new tab, go to the Prometheus app `http://localhost:9090`.

1. On the top menu, select **Status** and then select **Targets**.

    :::image type="content" source="../media/prometheus.png" alt-text="Screenshot that shows the configured Prometheus app showing the health of the eShopLite app." lightbox="../media/prometheus.png":::
  
    You should see the **Products** and **Store** services listed as **UP**.

1. On the **PORTS** tab, select **Open in Browser** for **Grafana (3000)**. If you're running locally in Visual Studio Code, open a browser and, on a new tab, go to the Grafana app `http://localhost:3000`.
1. Enter the username **admin**.
1. Enter the password **grafana**.
1. Select **Create your first dashboard**.
1. Select **Import dashboard**.
1. On a new tab, go to [GitHub](https://aka.ms/dotnet/grafana-source) and open the [ASP.NET Core dashboard json](https://github.com/dotnet/aspire/blob/main/src/Grafana/dashboards/aspnetcore.json) file.
1. Copy the *Raw* file.
1. Paste the JSON into the **Import via dashboard JSON model** text box.
1. Select **Load**.
1. In the **Prometheus data source** dropdown, select **Prometheus**.
1. Select **Import**.

    :::image type="content" source="../media/grafana.png" alt-text="Screenshot that shows an ASP.NET dashboard in Grafana." lightbox="../media/grafana.png":::

    You should see a dashboard showing metrics for the **Products** and **Store** services. Select the **Job** to change between the two services.

1. On the **TERMINAL** pane, select <kbd>Ctrl</kbd>+<kbd>C</kbd> to stop the app.

## Add Zipkin

You now extend the tracing capabilities of the app by adding Zipkin. As you did before, you add a Zipkin container to your app and configure it to connect to the OpenTelemetry collector. Then you add the OpenTelemetry Zipkin exporter to your app.

1. In Visual Studio Code, on the **EXPLORER** pane, select the *docker-compose.yml* file inside the *dotnet-observability* folder.

1. Add `prometheus` and `zipkin` in the `depends_on` for the `frontend`.

    ```yml
    depends_on: 
      - backend
      - prometheus
      - zipkin 
    ```

1. Add `prometheus` in the `depends_on` for the `backend`.

   ```yml
    depends_on: 
      - prometheus
    ```

1. Add environmental variables for Zipkin to **BOTH** `frontend` and `backend`:

    ```yml
    environment: 
      - ZIPKIN_URL=http://zipkin:9411    
    ```

    The two services should look like this:

    ```yml
    frontend:
      image: storeimage
      build:
        context: .
        dockerfile: ./eShopLite/Store/Dockerfile
      environment: 
        - ProductEndpoint=http://backend:8080
        - ZIPKIN_URL=http://zipkin:9411
      ports:
        - "32000:8080"
      depends_on: 
        - backend
        - prometheus
        - zipkin
  
    backend:
      image: productservice
      build: 
        context: .
        dockerfile: ./eShopLite/Products/Dockerfile
      environment: 
        - ZIPKIN_URL=http://zipkin:9411

      ports: 
        - "32001:8080"
      depends_on: 
        - prometheus    
    ```

1. Add this YAML to the bottom of the file:

    ```yml
      zipkin:
        image: openzipkin/zipkin
        ports:
          - 9411:9411
    ```

    The preceding YAML adds a Zipkin container to the app. It configures the Zipkin container to respond on port **9411**.

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

1. On the **TERMINAL** pane, go to the *Diagnostics* folder.

    ```bash
    cd ./eShopLite/Diagnostics/
    ```

1. Add the Zipkin export packages.

    ```dotnetcli
    dotnet add package OpenTelemetry.Exporter.Zipkin --prerelease
    ```

1. On the **EXPLORER** pane, expand the *Diagnostics* folder and then select **DiagnosticServiceCollectionExtensions.cs**.
1. At the bottom of the tracing providers, add Zipkin:

    ```csharp
    // add the tracing providers
    .WithTracing(tracing =>
    {
      tracing.SetResourceBuilder(resource)
                  .AddAspNetCoreInstrumentation()
                  .AddHttpClientInstrumentation()
                  .AddSqlClientInstrumentation()
                  .AddZipkinExporter(zipkin =>
                  {
                    var zipkinUrl = configuration["ZIPKIN_URL"] ?? "http://zipkin:9411";
                    zipkin.Endpoint = new Uri($"{zipkinUrl}/api/v2/spans");
                  });
    });
    ```

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

1. On the **TERMINAL** pane at the bottom, go to the *dotnet-observability/eShopLite* folder.

    ```bash
    cd ..
    ```

1. Update the apps containers.

    ```dotnetcli
    dotnet publish /p:PublishProfile=DefaultContainer 
    ```

1. Go to the *dotnet-observability* folder, and start the app with Docker:

    ```bash
    cd ..
    docker compose up
    ```

1. On the **PORTS** tab, select **Open in Browser** for **Prometheus (9090)**. If you're running locally in Visual Studio Code, open a new browser tab and go to the Zipkin app `http://localhost:9411`.
1. On the menu, select **Dependencies**.

    :::image type="content" source="../media/zipkin.png" alt-text="Screenshot that shows Zipkin showing the dependencies of the eShopLite app Store sending requests to the Products service.":::

1. On the **TERMINAL** pane, select <kbd>Ctrl</kbd>+<kbd>C</kbd> to stop the app.

## Add Application Insights

The last step is to add Application Insights to your app.

### Create the Application Insights resource in Azure

1. In Visual Studio Code, on the **TERMINAL** pane, sign in to Azure.

    ```azurecli
    az login --use-device-code
    ```

1. View your selected Azure subscription.

    ```azurecli
    az account show -o table
    ```

    If the wrong subscription is selected, select the correct one by using the [az account set](/cli/azure/account#az-account-set) command.

1. Add the extension for Application Insights.

    ```azurecli
    az extension add -n application-insights
    ```

1. Create an Application Insights resource.

    ```azurecli
    az monitor app-insights component create --app eShopLiteInsights --location eastus --kind web -g eShopLite
    ```

    You should see this output:

    ```console
    {
      "appId": "fb6e1af0-7556-469d-a31f-85e4550c8fde",
      "applicationId": "eShopLiteInsights",
      "applicationType": "web",
      "connectionString": "InstrumentationKey=00000000-0000-0000-0000-000000000000;IngestionEndpoint=https://eastus-2.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/",
      "creationDate": "2023-11-10T16:50:00.950726+00:00",
      "disableIpMasking": null,
      "etag": "\"3a02952a-0000-0100-0000-654e5f380000\"",
      "flowType": "Bluefield",
      "hockeyAppId": null,
      "hockeyAppToken": null,
      "id": "/subscriptions/7eebce2a-0884-4df2-8d1d-2a3c051e47fe/resourceGroups/eShopLite/providers/microsoft.insights/components/eShopLiteInsights",
      "immediatePurgeDataOn30Days": null,
      "ingestionMode": "ApplicationInsights",
      "instrumentationKey": "00000000-0000-0000-0000-000000000000",
      "kind": "web",
      "location": "eastus",
      "name": "eShopLiteInsights",
      "privateLinkScopedResources": null,
      "provisioningState": "Succeeded",
      "publicNetworkAccessForIngestion": "Enabled",
      "publicNetworkAccessForQuery": "Enabled",
      "requestSource": "rest",
      "resourceGroup": "eShopLite",
      "retentionInDays": 90,
      "samplingPercentage": null,
      "tags": {},
      "tenantId": "7eebce2a-0884-4df2-8d1d-2a3c051e47fe",
      "type": "microsoft.insights/components"
    }
    ```

    From the preceding returned JSON, copy the `connectionString`, excluding the ". For example:

    `InstrumentationKey=b851fa75-85a2-42f7-bb6f-413725d9d8ba;IngestionEndpoint=https://eastus-2.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/`

1. In Visual Studio Code, on the **EXPLORER** pane, select the *docker-compose.yml* file.
1. You add an environment variable that the diagnostics project uses to connect to Application Insights. Add this YAML to the **Store** service:

    ```yml
    environment:
      - APPLICATIONINSIGHTS_CONNECTION_STRING=InstrumentationKey=b851fa75-85a2-42f7-bb6f-413725d9d8ba;IngestionEndpoint=https://eastus-2.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/
    ```

    Replace the preceding connection string with the one you copied from the Azure CLI.

1. Repeat these steps for the **Products** service. The final YAML should look like this:

    ```yml
      frontend:
        image: storeimage
        build:
          context: .
          dockerfile: ./eShopLite/Store/Dockerfile
        environment: 
          - ProductEndpoint=http://backend:8080
          - ZIPKIN_URL=http://zipkin:9411
          - APPLICATIONINSIGHTS_CONNECTION_STRING=InstrumentationKey=b851fa75-85a2-42f7-bb6f-413725d9d8ba;IngestionEndpoint=https://eastus-2.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/
        ports:
          - "32000:8080"
        depends_on: 
          - backend
          - prometheus
          - zipkin
    
      backend:
        image: productservice
        build: 
          context: .
          dockerfile: ./eShopLite/Products/Dockerfile
        environment: 
          - ZIPKIN_URL=http://zipkin:9411
          - APPLICATIONINSIGHTS_CONNECTION_STRING=InstrumentationKey=b851fa75-85a2-42f7-bb6f-413725d9d8ba;IngestionEndpoint=https://eastus-2.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/
        
    ```

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

1. On the **TERMINAL** pane, go to the *Diagnostics* folder.

    ```bash
    cd .\eShopLite\Diagnostics\ 
    ```

1. Add the Application Insights exporter package.

    ```dotnetcli
    dotnet add package Azure.Monitor.OpenTelemetry.AspNetCore --prerelease
    ```

1. On the **EXPLORE** pane, select the *Diagnostics* folder and then select **DiagnosticServiceCollectionExtensions.cs**.
1. At the top of the file, add this `using` statement:

    ```csharp
    using Azure.Monitor.OpenTelemetry.AspNetCore;
    ```

1. Below `var otelBuilder = services.AddOpenTelemetry();`, add this code:

    ```csharp
    if (!string.IsNullOrEmpty(configuration["APPLICATIONINSIGHTS_CONNECTION_STRING"]))
    {
      otelBuilder.UseAzureMonitor();
    }
    ```

1. Select <kbd>Ctrl</kbd>+<kbd>S</kbd> to save the file.

1. On the **TERMINAL** pane at the bottom, go to the *dotnet-observability/eShopLite* folder.

    ```bash
    cd ..
    ```

1. Update the apps containers.

    ```dotnetcli
    dotnet publish /p:PublishProfile=DefaultContainer 
    ```

1. Go to the *dotnet-observability* folder, and start the app with Docker:

    ```bash
    cd ..
    docker compose up
    ```

1. Sign in to the Azure portal with the same credentials you used to sign in to the Azure CLI.
1. In the Azure portal, select **Resource groups**.
1. Select the **eShopLite** resource group.
1. Select the **eShopLiteInsights** Application Insights resource.
1. Select the **Application Dashboard**.

    :::image type="content" source="../media/app-insights.png" alt-text="Screenshot that shows Application Insights showing the health of the eShopLite app." lightbox="../media/app-insights.png":::

1. To see changes to metrics, go to the **:::no-loc text="eShopLite":::** app and change stock. Then refresh the Application Insights dashboard.

1. On the **TERMINAL** pane, press <kbd>Ctrl</kbd>+<kbd>C</kbd> to stop the app.
