This unit focuses on resolving mannequin accounts to preserve contributor attribution, establishing scalable governance across your GitHub repos, and enforcing consistent security practices. You’ll automate enforcement, reclaim contributor identities, and implement guardrails that promote safe, reliable collaboration from day one.

**In this unit, you'll learn:**
- How to identify and reclaim mannequin accounts in bulk or individually
- The implications of EMU, invitations, and limitations on mannequin resolution
- How to apply baseline governance (branch protection, CODEOWNERS, security features)
- How to validate governance coverage across all repositories

### Why this matters

Mannequins appear when Git commit authors don't map to GitHub users. Reclaiming them preserves contributor attribution, PR ownership, and audit integrity.

### How to resolve mannequins

The GitHub migration tools can generate a mannequin mapping CSV at the **organization level**. The typical workflow is:

1. **Generate the mannequin CSV** (tool depends on your migration extension)
   * For GEI (GitHub → GitHub migrations):
   ```bash
   gh gei generate-mannequin-csv --github-target-org DESTINATION --output mannequins.csv
   # Optionally include previously reclaimed mannequins:
   # gh gei generate-mannequin-csv --github-target-org DESTINATION --output mannequins.csv --include-reclaimed
   ```
   * For Azure DevOps source (ADO2GH):
   ```bash
   gh ado2gh generate-mannequin-csv --github-org DESTINATION --output mannequins.csv
   # Optionally include previously reclaimed mannequins:
   # gh ado2gh generate-mannequin-csv --github-org DESTINATION --output mannequins.csv --include-reclaimed
   ```
   * For Bitbucket Server (BBS2GH) and other extensions, use the corresponding `generate-mannequin-csv` command.
1. **Edit the CSV** to map each mannequin to an existing organization member.
   * CSV format: `mannequin-login,target-user` (one mapping per line).
   * The migration tool outputs mannequin display names/logins - **you must supply the target username** that exists in the destination org.
1. **Reclaim mannequins in bulk** (org owners only):
   * GEI:
   ```bash
   gh gei reclaim-mannequin --github-target-org DESTINATION --csv mannequins.csv
   ```
   * ADO2GH:
   ```bash
   gh ado2gh reclaim-mannequin --github-org DESTINATION --csv mannequins.csv
   ```
   * BBS2GH:
   ```bash
   gh bbs2gh reclaim-mannequin --github-org DESTINATION --csv mannequins.csv
   ```
1. **(Optional) Reclaim individually** (if you prefer per-mannequin actions):
    ```bash
    gh gei reclaim-mannequin --github-target-org DESTINATION --mannequin-user MANNEQUIN --target-user USERNAME
    # or for ADO2GH:
    gh ado2gh reclaim-mannequin --github-org DESTINATION --mannequin-user MANNEQUIN --target-user USERNAME
    ```

> [!NOTE]
> Only **organization owners** can reclaim mannequins. The CSV is generated by the migration tool and must be edited with the mapping you want - you cannot simply invent mappings without the generated inputs.

### Invitation behavior and EMU

* By default, reclaiming **sends an attribution invitation** to the target user; the mannequin is not reattributed until the user accepts.
* For **Enterprise Managed Users (EMU)**, you can skip the invitation and immediately reattribute by adding `--skip-invitation` to the reclaim command (CLI only).

### Important constraints & caveats

* You **cannot reclaim mannequins after a repository has been transferred** to another organization. Reclaim mannequins **before** any repo transfers.
* You can only target **existing organization members**. Ensure target users are added to the org before running reclaim.
* **Reclaiming mannequins does not change Git commit authorship.** Commit attribution is based on commit email addresses; users may need to add the appropriate email to their GitHub account (unless EMU limitations prevent that).
* Reclaiming does **not** automatically grant repository access. If the target user needs repo access, assign it separately (teams or direct access).

> [!TIP]
> Keep a copy of the original generated CSV (and any intermediate edits) for audit trails and for rollback/verification purposes.

### Tips for accurate mappings

* Use **migration logs** and the generated CSV to identify mannequin display names/logins.
* Cross-check **commit author emails**, PR metadata, and comments to build correct mappings.
* Prioritize mannequins for **active PRs**, critical compliance history, and high-visibility repos first.

### Success criteria

* Attribution invitations are delivered and accepted (or skipped for EMU).
* PR authors and other non-commit contributions are shown as the real users rather than mannequins.
* Audit reports reflect corrected attribution for reclaimed mannequins.
* Commits remain unchanged (commit author attribution still follows commit email rules).

### Lock in governance and security
Start from a secure default, then relax policies thoughtfully where needed. Make the safe path the easy path using rulesets and templates.

### Apply baseline governance at scale
With Organization Rulesets established in your target environment setup (as covered in the first module), you now have centralized policy management in place. Organization Rulesets automatically enforce governance across all repositories, significantly reducing the need for repository-by-repository configuration.

### Validate governance coverage
With Organization Rulesets in place, most governance should be automatically enforced. However, you should still validate coverage and monitor compliance across all repositories.
Create a monthly validation script to ensure consistent governance application:

```bash
# governance-check.sh (enhanced for Organization Rulesets)
GITHUB_ORG="your-github-org"

# Check Organization Rulesets status
echo "=== Organization Rulesets Status ==="
gh api "/orgs/$GITHUB_ORG/rulesets" | jq -r '.[] | "\(.name): \(.enforcement) (\(.conditions.repository_name.include // ["all"]) | join(","))"'

# Validate repository protection coverage
echo "=== Repository Protection Coverage ==="
TOTAL=$(gh repo list "$GITHUB_ORG" --json name | jq length)
PROTECTED=0
for r in $(gh repo list "$GITHUB_ORG" --json name --jq '.[].name'); do
gh api "/repos/$GITHUB_ORG/$r/branches/main/protection" --silent && PROTECTED=$((PROTECTED+1))
done
echo "Branch protection coverage: $PROTECTED / $TOTAL ($(($PROTECTED*100/$TOTAL))%)"

# Check ruleset enforcement across repositories
echo "=== Ruleset Enforcement Validation ==="
for r in $(gh repo list "$GITHUB_ORG" --json name --jq '.[].name'); do
RULESETS=$(gh api "/repos/$GITHUB_ORG/$r/rulesets" | jq length)
echo "$r: $RULESETS ruleset(s) applied"
done
```
### Success criteria for governance

- **Organization Rulesets active and enforcing** - Centralized policies applied across all repositories
- **Branch protection active on mainline branches** - Either through rulesets or repository-specific rules
- **CODEOWNERS present and working** - Automated review assignments functioning
- **Secret scanning and Dependabot security updates enabled** - Security features active on private repos
- **Merge strategies consistent with team norms** - Squash merge, auto-delete head branches configured
- **Consistent policy application** - All repositories inherit the same baseline security and quality standards
