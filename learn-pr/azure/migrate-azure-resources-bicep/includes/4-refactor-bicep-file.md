After the convert and migrate phases of converting your templates to Bicep, you need to improve the file. This process is called _refactoring_. The third phase of the recommended workflow for migrating your JSON ARM template and Azure resources to Bicep is the refactor phase:

:::image type="content" source="../media/4-refactor-phase.png" alt-text="Diagram of the refactor phase of the recommended workflow for migrating Azure resources to Bicep." border="false":::

The main focus of the *refactor* phase is to improve the quality of your Bicep code. Improvements can include changes, such as adding code comments, that bring the template in line with your template standards.

The refactor phase consists of eight steps, which you do in any order:

- Review resource API versions.
- Review the linter suggestions in your new Bicep file.
- Revise parameters, variables, and symbolic names.
- Simplify expressions.
- Review child and extension resources.
- Modularize.
- Add comments.
- Follow Bicep best practices.

Here's the output of the Bicep `decompile` command against a JSON template that creates an App Service plan:

```bicep
@description('Location for resources.')
param location string = resourceGroup().location

@allowed([
  'prod'
  'dev'
  'test'
])
@description('The list of allowed environment names.')
param environment string = 'prod'

@allowed([
  'P1v3'
  'P2v3'
  'P3v3'
])
@description('The list of allowed App Service Plan SKUs.')
param appServicePlanSku string = 'P1v3'

@minValue(1)
@maxValue(10)
@description('The number of allowed App Service Plan instances.')
param appServicePlanInstanceCount int = 1

var appServicePlanName_var = 'plan-${environment}-001'

resource appServicePlanName 'Microsoft.Web/serverfarms@2020-12-01' = {
  name: appServicePlanName_var
  location: location
  sku: {
    name: appServicePlanSku
    capacity: appServicePlanInstanceCount
  }
  kind: 'app'
  properties: {}
}

output appServicePlanId string = appServicePlanName.id
```

If you deploy this Bicep template as-is, the deployment will succeed, but you can improve the template to bring it line with your template standards.

### Review resource API versions

When you use Bicep to interact with your Azure resources, you specify an _API version_ to use. As Azure products change and improve, newer API versions are released to provide access to new functionality. When you export Azure resources, the exported template might not have the latest API version for a resource type. If you need specific properties for future deployments, update the API to the appropriate version. It's good practice to review the API versions for each exported resource.

Consider using the [Azure ARM template reference](/azure/templates/?azure-portal=true) to help verify the appropriate API versions and resource properties for your template.

### Review the linter suggestions in your new Bicep file

When you create Bicep files by using the [Bicep extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-bicep&azure-portal=true), the linter runs automatically and highlights suggestions and errors in your code. Many of the suggestions and errors include an option to apply a quick fix to the issue. Review these recommendations and adjust your Bicep file.

### Revise parameters, variables, and symbolic names

If your infrastructure supports multiple environments, such as production and development, create parameters that support these environments. A good parameter naming convention will make it easy to customize your deployments per environment.

It's possible that the names of parameters, variables, and symbolic names generated by the decompiler won't match your standard naming convention. Review the generated names and make adjustments as necessary.

For example, in the converted template, the variable named `appServicePlanName_var` has `_var` appended to the end of the original variable name:

:::code language="bicep" source="code/4-app-service-plan.bicep" range="20-27" highlight="6" :::

For clarity, it's a good idea to remove `_var` from the variable name. But, when you rename the variable, its new name conflicts with the symbolic name of the App Service plan resource. So, it's a good idea to rename resources first, and then rename the variables that are used in their definitions.

[!include[Tip - How to use Visual Studio Code to rename Bicep symbols.](../../includes/azure-template-bicep-tip-rename.md)]

### Simplify expressions

The decompile process might not always take advantage of some of Bicep's features. Review any expressions that are generated in the conversion and simplify them. For example, the decompiled template might include a `concat()` or `format()` function that you can simplify by using string interpolation. Review any suggestions from the linter and make adjustments as necessary.

### Review child and extension resources

Bicep offers multiple ways to declare child and extension resources, including concatenating the names of your resources, using the `parent` keyword, and using nested resources.

Consider reviewing these resources after decompilation to make sure that the structure meets your standards. For example, ensure that you don't use string concatenation to create child resource names. Instead, use the `parent` property or a nested resource. Similarly, you can reference subnets either as properties of a virtual network or as separate resources.

### Modularize

If you're converting a template that has many resources, consider breaking the individual resource types into modules for simplicity. Using modules in Bicep helps reduce the complexity of your template deployments.

> [!NOTE]
> It's possible to use your JSON templates as modules in a Bicep deployment. Bicep has the ability to recognize JSON modules and reference them similarly to how you use Bicep modules.

### Add comments and descriptions

Good Bicep code is _self-documenting_. In Bicep, you can add comments and descriptions to your code to document your infrastructure. Comments and descriptions can help your teammates understand the code and increase confidence when changes are made. Both comments and descriptions are visible when you work with the file in Visual Studio Code, for example when you need to specify a parameter value for a module, but when you deploy the Bicep file to Azure, the comments are ignored.

Bicep supports both single-line comments using a `//` character sequence and multi-line comments that start with a `/*` and end with a `*/`. You can add comments to apply to specific lines in your code or to sections of code.

You can add a multi-line comment at the beginning of the file:

```bicep
/*
  This Bicep file was developed by the web team.
  It deploys the resources we need for our toy company's website.
*/
```

Single-line comments can be added as headers for sections of code or on individual lines to describe the code:

:::code language="bicep" source="code/4-app-service-plan-updated.bicep" range="34-46" highlight="1,6,9,12" :::

Bicep provides the `@description` decorator that you can use to document the purpose of your parameters, variables, resources, modules, and outputs. You can add the description on the line above the item you are describing:

```bicep
@description('The name of the App Service Plan.)
param appServicePlanName string
```

### Follow Bicep best practices

Make sure that your Bicep file follows standard recommendations. Review [Bicep best practices](/azure/azure-resource-manager/bicep/best-practices?azure-portal=true) for anything you might have missed.

### The converted template

After you make the appropriate improvements, review the final template before you deploy it. Take a look at a final converted example template that includes the revised names and added comments:

```bicep
/*
  This Bicep file was developed by the web team.
  It deploys the resources we need for our toy company's website.
*/

// Parameters
@description('Location For all resources.')
param location string = resourceGroup().location

@allowed([
  'prod' // Production environment
  'dev' // Development environment
  'test' // Test environment
])
@description('The list of allowed environment names.')
param environment string = 'prod'

@allowed([
  'P1v3'
  'P2v3'
  'P3v3'
])
@description('The list of allowed App Service plan SKUs.')
param appServicePlanSku string = 'P1v3'

@minValue(1)
@maxValue(10)
@description('The number of allowed App Service plan instances.')
param appServicePlanInstanceCount int = 1

// Variables
@description('The name of the App Service Plan.)
var appServicePlanName = 'plan-${environment}-001'

// Resource - App Service Plan
@description(')
resource appServicePlan 'Microsoft.Web/serverfarms@2020-12-01' = {
  name: appServicePlanName
  location: location
  sku: {
    name: appServicePlanSku // Specifies the SKU of the App Service plan.
    capacity: appServicePlanInstanceCount
  }
  kind: 'app' // Specifies a Windows App Service plan.
}

// Outputs
@description('The resource Id of the App Service Plan.)
output appServicePlanId string = appServicePlan.id
```
