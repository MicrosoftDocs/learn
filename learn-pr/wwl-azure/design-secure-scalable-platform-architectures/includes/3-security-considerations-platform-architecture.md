Security in platform architecture isn't just about implementing protective measures but ensuring those measures are consistently applied, monitored, and adapted to evolving threats. Modern platform engineering embraces practices like *Security as Code* and *Policy as Code* to achieve this. By codifying security configurations and policies, organizations can automate the enforcement of security standards across environments, ensuring uniformity and reducing human error. These practices enable platforms to remain agile and secure, as policies are version-controlled, auditable, and easily integrated into deployment pipelines.

Identity and access management (IAM) is at the heart of platform security, managing who can access resources and what actions they can perform. Applying robust IAM frameworks ensures platforms are protected against unauthorized access while enabling seamless operations. Similarly, effective secrets and key management is vital to safeguard sensitive credentials, encryption artifacts, and connection strings. By centralizing these practices and using tools designed for secure storage and rotation, organizations reduce the risk of data exposure and maintain control over critical assets. Together, these elements form the backbone of a secure platform architecture.

### Security as Code and Policy as Code

Provisioning infrastructure is a fundamental aspect of platform management, but ensuring these environments are both secure and compliant with organizational standards is equally critical. The concept of *Security as Code* addresses this by embedding security practices directly into the development and deployment lifecycle, treating security configurations and tests as integral parts of the codebase. Complementing this is *Policy as Code*, which codifies operational and security policies into configuration files stored in source control repositories. These approaches automate the enforcement of security measures and governance standards, enabling proactive identification of risks, mitigation of vulnerabilities, and adherence to compliance requirements. Together, these paradigms streamline secure platform design, prevent configuration drift, and support scalable, repeatable processes.

Some of the commonly used Policy as Code and Security as Code techniques include:

 -  **Azure Policy**: Azure Policy enables organizations to define and enforce governance standards for Azure and Arc-enabled non-Azure resources. By applying policies at scale, you maintain resource compliance with security and operational requirements, offering detailed compliance reports and remediation actions to address any potential deviations.
 -  **Open Policy Agent (OPA)**: OPA is an open-source policy engine that allows developers to implement fine-grained policies across a wide range of systems. It supports dynamic decision-making by integrating with applications, services, and APIs, offering a flexible way to enforce custom policies.
 -  **GitHub Advanced Security**: GitHub Advanced Security provides built-in tools for code scanning, secret scanning, and dependency reviews. By identifying vulnerabilities in code and dependencies during the development phase, it reduces the risk of security flaws being introduced into production.
 -  **GitHub CODEOWNERS**: CODEOWNERS is a GitHub feature that allows teams to designate specific owners for files or directories in a repository. This streamlines the review process, ensuring that any changes to critical configurations or policies are vetted by appropriate experts, enhancing security governance.

### Identity and Access Management

Managing identities and access across multiple systems is an inherent part of platform engineering. As platforms grow in complexity, integrating these systems securely while maintaining user and team data consistency becomes a challenge. A suitable strategy for Identity and Access Management (IAM) is essential to ensure secure operations and seamless collaboration. This involves direct integration with identity providers like Microsoft Entra ID, which supports role-based access control (RBAC) and conditional access policies. Direct integration not only enhances security by using native SDKs and APIs but also ensures that identity policies are continuously evaluated for every action, minimizing risks associated traditionally with static configurations.

Effective IAM should also include robust management of secrets and keys, which, in many cases, serve to secure authentication and communication across systems. By centralizing these elements within services like Azure Key Vault, platforms can ensure that credentials and sensitive information are protected against unauthorized access. This approach aligns with modern security principles, ensuring that every component operates within a tightly controlled access framework.

However, as platform engineering evolves, access management might require extra provisions to address more complex scenarios. In particular, platform engineering tends to rely on the concept of "teams" to enhance role-based access control (RBAC) and facilitate effective data aggregation. A team in this context isn't merely a single group within an identity provider but a collection of individuals with varied roles working toward a common purpose. This multi-role approach allows platforms to streamline data discovery and reporting, enabling roll-up information in tools like dashboards. Unlike general identity provider groups, which assign multiple users to one role, a team links multiple groups to varying roles, creating a more flexible and functional model for managing platform access.

:::image type="content" source="../media/team-roles-8c3dd1a7.png" alt-text="Diagram showing the functional model for managing platform access, including team, roles and groups.":::


Teams can be defined and managed through different sources, depending on the tools and frameworks in use. For instance, adopting a "Teams as Code" (TaC) pattern allows platforms to treat team configurations as version-controlled code. By tracking changes in repositories, platform providers can cache team metadata and user profiles, ensuring updates are auditable and easily automated. Alternatively, tools like Azure Dev Center Projects can directly integrate with identity provider constructs, providing pre-built RBAC frameworks to simplify team definition and role assignments. These methods enhance consistency across systems while reducing manual efforts in managing memberships and permissions.

:::image type="content" source="../media/eac-teams-as-code-with-platform-2465e9ea.png" alt-text="Diagram showing the team as code pattern, including the user creating the PR, and code in git.":::


In addition, many downstream systems abstract groups and users into their own formats, which can complicate data aggregation and RBAC implementation. For example, APIs in downstream systems may not directly use identity provider attributes, such as Entra ID's Object ID, requiring platforms to implement custom attribute mappings. Patterns like TaC help resolve this challenge by storing relationships between teams or group IDs in a centralized, secure repository. This repository becomes a source of truth, with CI/CD pipelines ensuring downstream systems are updated consistently. By maintaining mappings and using pull requests to control changes, platforms can manage team and user identities across systems efficiently and securely, avoiding misalignments and improving interoperability.

This effectively enables the following relationships to be stored for in API calls:

:::image type="content" source="../media/pe-api-calls-22146d20.png" alt-text="Diagram showing the functional model for managing platform access, including team, roles, groups and teams.":::
